为什么要用C扩展
C是静态编译的，执行效率比PHP代码高很多。同样的运算代码，使用C来开发，性能会比PHP要提升数百倍。IO操作如CURL，因为耗时主要在IOWait上，C扩展没有明显优势。

另外C扩展是在进程启动时加载的，PHP代码只能操作Request生命周期的数据，C扩展可操作的范围更广。

第一步
下载PHP的源代码，如php-5.4.16。解压后进入php-5.4.16\ext目录。输入 ./ext_skel –extname=myext，myext就是扩展的名称，执行后生成myext目录。

ext_skel是PHP官方提供的用于生成php扩展骨架代码的工具。

cd myext。可以看到php_myext.h、myext.c、config.m4等几个文件。config.m4是AutoConf工具的配置文件，用来修改各种编译选项。

第二步
修改config.m4，将

dnl PHP_ARG_WITH(myext, for myext support,
dnl Make sure that the comment is aligned:
dnl [  --with-myext             Include myext support])
修改为

PHP_ARG_WITH(myext, for myext support,
[  --with-myext             Include myext support])
下边还有一个 –enable-myext，是表示编译到php内核中。with是作为动态链接库载入的。

第三步
修改php_myext.h，看到PHP_FUNCTION(confirm_myext_compiled); 这里就是扩展函数声明部分，可以增加一行 PHP_FUNCTION(myext_helloworld); 表示声明了一个myext_helloworld的扩展函数。

然后修改myext.c，这个是扩展函数的实现部分。

const zend_function_entry myext_functions[] = {
        PHP_FE(confirm_myext_compiled,  NULL)           /* For testing, remove later. */
        PHP_FE(myext_helloworld,  NULL)
        PHP_FE_END      /* Must be the last line in myext_functions[] */
};
这的代码是将函数指针注册到Zend引擎，增加一行PHP_FE(myext_helloworld,  NULL)（后面不要带分号）。

第四步
在myext.c末尾加myext_helloworld的执行代码。

PHP_FUNCTION(myext_helloworld)
{
        char *arg = NULL;
	int arg_len, len;
	char *strg;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &arg, &arg_len) == FAILURE) {
		return;
	}
	php_printf("Hello World!\n");
	RETRUN_TRUE;
}
zend_parse_parameters是用来接受PHP传入的参数，RETURN_XXX宏是用来返回给PHP数据。

第五步
在myext目录下依次执行phpize、./configure 、make、make install。然后修改php.ini加入extension=myext.so

执行php -r “myext_helloworld(‘test’);”，输出hello world!