在应用的迭代演进过程中，随着系统访问量提高，业务复杂度提高，代码复杂度提高，应用逐渐从单体式架构向面向服务的分布式架构转变。RPC（Remote Procedure Call Protocol远程过程调用）是分布式架构的核心，按响应方式分如下两种：

同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作

异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。

同步调用的实现方式有WebService和RMI。Web Service提供的服务是基于web容器的，底层使用http协议，因而适合不同语言异构系统间的调用。RMI实际上是Java语言的RPC实现，允许方法返回 Java 对象以及基本数据类型，适合用于JAVA语言构建的不同系统间的调用。

异步调用的JAVA实现版就是JMS(Java Message Service)，目前开源的的JMS中间件有Apache社区的ActiveMQ和Kafka，另外有阿里的RocketMQ，昨天（2016年11月28日）看到的新闻阿里已经将此组件捐献给Apache社区基金组织。

下面重点对RPC同步调用的原理进行探讨。简单来说一个RPC架构里包含如下4个组件:

1、 客户端(Client)：服务调用方

2、 客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方

3、 服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务

4、 服务端(Server)：真正的服务提供者。


-----------------------------------------------------------------------------------------------------------------------------
1、 服务调用方（client）调用以本地调用方式调用服务；

2、 client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；在Java里就是序列化的过程

3、 client stub找到服务地址，并将消息通过网络发送到服务端；

4、 server stub收到消息后进行解码,在Java里就是反序列化的过程；

5、 server stub根据解码结果调用本地的服务；

6、 本地服务执行处理逻辑；

7、 本地服务将结果返回给server stub；

8、 server stub将返回结果打包成消息，Java里的序列化；

9、 server stub将打包后的消息通过网络并发送至消费方

10、 client stub接收到消息，并进行解码, Java里的反序列化；

11、 服务调用方（client）得到最终结果。

RPC框架的目标就是把2-10步封装起来，把调用、编码/解码的过程封装起来，让用户像调用本地服务一样的调用远程服务。要做到对客户端（调用方）透明化服务， RPC框架需要考虑解决如下问题：

1、 服务端提供的服务如何发布，客户端如何发现服务；

2、 如何对请求对象和返回结果进行序列化和反序列化；

3、 如何更高效进行网络通信。



以上问题在一些开源的RPC框架里都有比较好的解决，如阿里的Dubbo，Facebook的Thrift。有兴趣的同学可以对这两个框架进行深入学习研究。